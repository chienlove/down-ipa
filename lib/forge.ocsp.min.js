const forge = {};
(function() {
  function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
  (function (Buffer){(function (){
  var forge = module.exports = require('./forge');
  forge.md = forge.md || {};
  forge.asn1 = forge.asn1 || require('./asn1');
  forge.util = require('./util');
  forge.pki = forge.pki || {};
  forge.pki.oids = forge.pki.oids || require('./oids').oids;
  forge.ocsp = forge.ocsp || {};

  const { util, asn1, pki, ocsp } = forge;

  // === OCSP createRequest support ===
  forge.ocsp.createRequest = function({ certificate, issuer }) {
    if (!certificate || !issuer) throw new Error("Missing certificate or issuer");

    const certID = ocsp.getCertID(certificate, issuer);

    const tbsRequest = {
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [ocsp.request(certID)]
        }
      ]
    };

    const ocspRequest = {
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [tbsRequest]
    };

    return {
      toDer: () => Buffer.from(asn1.toDer(ocspRequest).getBytes(), 'binary'),
      length: asn1.toDer(ocspRequest).length()
    };
  };

  forge.ocsp.getCertID = function(cert, issuer) {
    const certSerial = cert.serialNumber;
    const issuerNameHash = forge.md.sha1.create().update(
      asn1.toDer(pki.getIssuer(cert)).getBytes()
    ).digest().getBytes();

    const issuerKeyHash = forge.md.sha1.create().update(
      issuer.publicKey.subjectPublicKeyInfo.subjectPublicKey
    ).digest().getBytes();

    return {
      hashAlgorithm: pki.oids['sha1'],
      issuerNameHash,
      issuerKeyHash,
      serialNumber: certSerial
    };
  };

  forge.ocsp.request = function(certID) {
    const oid = pki.oids['sha1'];
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, '')
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, certID.issuerNameHash),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, certID.issuerKeyHash),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, certID.serialNumber)
    ]);
  };

  forge.ocsp.decodeResponse = function(buffer) {
    const bytes = Buffer.isBuffer(buffer)
      ? buffer.toString('binary')
      : buffer;

    const obj = asn1.fromDer(bytes);

    const responseStatus = obj.value[0].value;
    const statusInt = responseStatus[0].value.charCodeAt(0);

    const statusText = {
      0: 'successful',
      1: 'malformedRequest',
      2: 'internalError',
      3: 'tryLater',
      5: 'sigRequired',
      6: 'unauthorized'
    }[statusInt] || 'unknown';

    const basicResp = obj.value[1]?.value[0];
    const tbsResp = basicResp?.value[0];
    const responses = tbsResp?.value[1];

    if (!responses || !responses.value || responses.value.length === 0) {
      return { status: statusText, isRevoked: false };
    }

    const singleResp = responses.value[0];
    const certStatus = singleResp.value[1];

    const certStatusTag = certStatus.type;
    let isRevoked = false;
    let revokedInfo = null;

    if (certStatusTag === 1) {
      isRevoked = true;
      const revocationTime = certStatus.value[0].value;
      revokedInfo = {
        revocationTime: new Date(revocationTime)
      };
    }

    return {
      status: statusText,
      isRevoked,
      revokedInfo
    };
  };
})();
}).call(this,require("buffer").Buffer)
},{"./asn1":2,"./forge":3,"./oids":4,"./util":5,"buffer":6}]
,
6:[function(require,module,exports){
  exports.Buffer = require('buffer').Buffer;
},{}]
}, {}, [1]);

export default forge;