// lib/forge.ocsp.min.js

export default function patchOCSP(forge) {
  forge.ocsp = forge.ocsp || {};

  forge.ocsp.createRequest = function({ certificate, issuer }) {
    if (!certificate || !issuer) throw new Error("Missing certificate or issuer");

    const certID = forge.ocsp.getCertID(certificate, issuer);

    const tbsRequest = {
      tagClass: forge.asn1.Class.UNIVERSAL,
      type: forge.asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          tagClass: forge.asn1.Class.UNIVERSAL,
          type: forge.asn1.Type.SEQUENCE,
          constructed: true,
          value: [forge.ocsp.request(certID)]
        }
      ]
    };

    const ocspRequest = {
      tagClass: forge.asn1.Class.UNIVERSAL,
      type: forge.asn1.Type.SEQUENCE,
      constructed: true,
      value: [tbsRequest]
    };

    return {
      toDer: () => Buffer.from(forge.asn1.toDer(ocspRequest).getBytes(), 'binary'),
      length: forge.asn1.toDer(ocspRequest).length
    };
  };

  forge.ocsp.getCertID = function(cert, issuer) {
    const certSerial = new forge.jsbn.BigInteger(cert.serialNumber, 16);
    const issuerNameHash = forge.md.sha1.create().update(
  forge.asn1.toDer(cert.issuer).getBytes()
).digest().getBytes();

    const issuerKeyHash = forge.md.sha1.create().update(
      issuer.publicKey.subjectPublicKeyInfo.subjectPublicKey
    ).digest().getBytes();

    return {
      hashAlgorithm: forge.pki.oids['sha1'],
      issuerNameHash,
      issuerKeyHash,
      serialNumber: certSerial.toByteArray()
    };
  };

  forge.ocsp.request = function(certID) {
    const oid = forge.pki.oids['sha1'];
    return forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, forge.asn1.oidToDer(oid).getBytes()),
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.NULL, false, '')
      ]),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, certID.issuerNameHash),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, certID.issuerKeyHash),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false, certID.serialNumber)
    ]);
  };

  forge.ocsp.decodeResponse = function(buffer) {
    const bytes = Buffer.isBuffer(buffer) ? buffer.toString('binary') : buffer;
    const obj = forge.asn1.fromDer(bytes);

    const responseStatus = obj.value[0].value;
    const statusInt = responseStatus[0].value.charCodeAt(0);

    const statusText = {
      0: 'successful',
      1: 'malformedRequest',
      2: 'internalError',
      3: 'tryLater',
      5: 'sigRequired',
      6: 'unauthorized'
    }[statusInt] || 'unknown';

    const basicResp = obj.value[1]?.value[0];
    const tbsResp = basicResp?.value[0];
    const responses = tbsResp?.value[1];

    if (!responses || !responses.value || responses.value.length === 0) {
      return { status: statusText, isRevoked: false };
    }

    const singleResp = responses.value[0];
    const certStatus = singleResp.value[1];

    const certStatusTag = certStatus.type;
    let isRevoked = false;
    let revokedInfo = null;

    if (certStatusTag === 1) {
      isRevoked = true;
      const revocationTime = certStatus.value[0].value;
      revokedInfo = { revocationTime: new Date(revocationTime) };
    }

    return {
      status: statusText,
      isRevoked,
      revokedInfo
    };
  };
}