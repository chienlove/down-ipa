export default function patchOCSP(forge) {
  forge.ocsp = forge.ocsp || {};

  forge.ocsp.createRequest = function({ certificate, issuer }) {
    if (!certificate || !issuer) throw new Error("Missing certificate or issuer");

    const certID = forge.ocsp.getCertID(certificate, issuer);

    const tbsRequest = {
      tagClass: forge.asn1.Class.UNIVERSAL,
      type: forge.asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          tagClass: forge.asn1.Class.UNIVERSAL,
          type: forge.asn1.Type.SEQUENCE,
          constructed: true,
          value: [forge.ocsp.request(certID)]
        }
      ]
    };

    const ocspRequest = {
      tagClass: forge.asn1.Class.UNIVERSAL,
      type: forge.asn1.Type.SEQUENCE,
      constructed: true,
      value: [tbsRequest]
    };

    const der = forge.asn1.toDer(ocspRequest);

    return {
      toDer: () => Buffer.from(der.getBytes(), 'binary'),
      length: der.length()
    };
  };

  forge.ocsp.getCertID = function(cert, issuer) {
    const certSerial = new forge.jsbn.BigInteger(cert.serialNumber, 16);

    const issuerNameHash = forge.md.sha1.create().update(
      forge.asn1.toDer(cert.issuer).getBytes()
    ).digest().getBytes();

    const issuerKeyHash = forge.md.sha1.create().update(
      issuer.publicKey.subjectPublicKeyInfo.subjectPublicKey
    ).digest().getBytes();

    return {
      hashAlgorithm: forge.pki.oids['sha1'],
      issuerNameHash,
      issuerKeyHash,
      serialNumber: certSerial.toByteArray()
    };
  };

  forge.ocsp.request = function(certID) {
    const oid = forge.pki.oids['sha1'];
    return forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, forge.asn1.oidToDer(oid).getBytes()),
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.NULL, false, '')
      ]),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, certID.issuerNameHash),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, certID.issuerKeyHash),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false, certID.serialNumber)
    ]);
  };

  forge.ocsp.decodeResponse = function(buffer) {
    try {
      const bytes = Buffer.isBuffer(buffer) ? buffer.toString('binary') : buffer;
      const obj = forge.asn1.fromDer(bytes);

      // Kiểm tra cấu trúc phản hồi cơ bản
      if (!obj || !obj.value || !Array.isArray(obj.value)) {
        return { status: 'malformedResponse', isRevoked: false };
      }

      // Xử lý responseStatus
      const responseStatus = obj.value[0]?.value;
      if (!responseStatus || !responseStatus[0]) {
        return { status: 'malformedResponse', isRevoked: false };
      }

      const statusInt = responseStatus[0].value.charCodeAt(0);
      const statusText = {
        0: 'successful',
        1: 'malformedRequest',
        2: 'internalError',
        3: 'tryLater',
        5: 'sigRequired',
        6: 'unauthorized'
      }[statusInt] || 'unknown';

      // Nếu không phải successful thì trả về luôn
      if (statusText !== 'successful') {
        return { status: statusText, isRevoked: false };
      }

      // Kiểm tra cấu trúc basicResp
      const basicResp = obj.value[1]?.value?.[0];
      if (!basicResp) {
        return { status: 'malformedResponse', isRevoked: false };
      }

      const tbsResp = basicResp.value?.[0];
      const responses = tbsResp?.value?.[1];

      if (!responses || !responses.value || responses.value.length === 0) {
        return { status: statusText, isRevoked: false };
      }

      const singleResp = responses.value[0];
      const certStatus = singleResp.value[1];

      const certStatusTag = certStatus.type;
      let isRevoked = false;
      let revokedInfo = null;

      if (certStatusTag === 1) {
        isRevoked = true;
        const revocationTime = certStatus.value[0].value;
        revokedInfo = { revocationTime: new Date(revocationTime) };
      }

      return {
        status: statusText,
        isRevoked,
        revokedInfo
      };
    } catch (error) {
      console.error('OCSP decode error:', error);
      return {
        status: 'decodeError',
        isRevoked: false,
        error: error.message
      };
    }
  };
}