export default function patchOCSP(forge) {
  forge.ocsp = forge.ocsp || {};

  forge.ocsp.getCertID = function(cert, issuer) {
    if (!cert || !issuer) {
      throw new Error('Missing certificate or issuer');
    }

    if (!cert.serialNumber || typeof cert.serialNumber !== 'string') {
      throw new Error('Invalid certificate serialNumber');
    }

    // Deep issuer public key validation
    const issuerKey = issuer.publicKey?.subjectPublicKeyInfo?.subjectPublicKey;
    if (!issuerKey || typeof issuerKey !== 'string') {
      console.error('Invalid Issuer Public Key:', {
        publicKeyExists: !!issuer.publicKey,
        subjectPublicKeyInfoExists: !!issuer.publicKey?.subjectPublicKeyInfo,
        subjectPublicKeyType: typeof issuerKey,
        issuerCert: {
          serialNumber: issuer.serialNumber,
          issuer: issuer.issuer.attributes.map(a => `${a.name || a.shortName}=${a.value}`)
        }
      });
      throw new Error('Issuer public key is invalid or missing');
    }

    let certSerial;
    try {
      certSerial = new forge.jsbn.BigInteger(cert.serialNumber, 16);
    } catch (e) {
      throw new Error(`Invalid serialNumber format: ${cert.serialNumber}`);
    }

    let issuerNameDer;
    try {
      issuerNameDer = forge.asn1.toDer(cert.issuer);
      if (typeof issuerNameDer.getBytes !== 'function') {
        throw new Error('Failed to encode issuer name');
      }
    } catch (e) {
      throw new Error(`Issuer encoding failed: ${e.message}`);
    }

    return {
      hashAlgorithm: forge.pki.oids['sha1'],
      issuerNameHash: forge.md.sha1.create()
        .update(issuerNameDer.getBytes())
        .digest().getBytes(),
      issuerKeyHash: forge.md.sha1.create()
        .update(issuerKey)
        .digest().getBytes(),
      serialNumber: certSerial.toByteArray()
    };
  };

  forge.ocsp.request = function(certID) {
    if (!certID || !certID.issuerNameHash || !certID.issuerKeyHash || !certID.serialNumber) {
      throw new Error('Invalid CertID structure');
    }

    const oid = forge.pki.oids['sha1'];
    return forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, 
          forge.asn1.oidToDer(oid).getBytes()),
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.NULL, false, '')
      ]),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, 
        certID.issuerNameHash),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, 
        certID.issuerKeyHash),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false, 
        certID.serialNumber)
    ]);
  };

  forge.ocsp.createRequest = function({ certificate, issuer }) {
    try {
      const certID = forge.ocsp.getCertID(certificate, issuer);
      const request = forge.ocsp.request(certID);

      const tbsRequest = forge.asn1.create(forge.asn1.Class.UNIVERSAL, 
        forge.asn1.Type.SEQUENCE, true, [
          forge.asn1.create(forge.asn1.Class.UNIVERSAL, 
            forge.asn1.Type.SEQUENCE, true, [request])
        ]);

      const ocspRequest = forge.asn1.create(forge.asn1.Class.UNIVERSAL, 
        forge.asn1.Type.SEQUENCE, true, [tbsRequest]);

      const der = forge.asn1.toDer(ocspRequest);
      
      return {
        toDer: () => Buffer.from(der.getBytes(), 'binary'),
        length: der.length()
      };
    } catch (error) {
      console.error('CreateRequest Error:', {
        message: error.message,
        certificate: certificate ? {
          serialNumber: certificate.serialNumber,
          issuer: certificate.issuer.attributes.map(a => `${a.name || a.shortName}=${a.value}`)
        } : null,
        issuer: issuer ? {
          serialNumber: issuer.serialNumber
        } : null
      });
      throw error;
    }
  };

  forge.ocsp.decodeResponse = function(buffer) {
    try {
      if (!buffer || buffer.length === 0) {
        return { status: 'emptyResponse', isRevoked: false };
      }

      const bytes = typeof buffer === 'string' ? buffer : buffer.toString('binary');
      const obj = forge.asn1.fromDer(bytes);

      if (!obj?.value?.length) {
        return { status: 'malformedResponse', isRevoked: false };
      }

      const responseStatus = obj.value[0]?.value?.[0]?.value?.charCodeAt(0);
      const statusMap = [
        'successful', 'malformedRequest', 'internalError', 
        'tryLater', null, 'sigRequired', 'unauthorized'
      ];
      const statusText = statusMap[responseStatus] || 'unknown';

      if (statusText !== 'successful') {
        return { status: statusText, isRevoked: false };
      }

      const singleResp = obj.value[1]?.value?.[0]?.value?.[0]?.value?.[1]?.value?.[0];
      const certStatus = singleResp?.value?.[1];

      if (!certStatus) {
        return { status: statusText, isRevoked: false };
      }

      const isRevoked = certStatus.type === 1;
      const revocationTime = isRevoked && certStatus.value?.[0]?.value 
        ? new Date(certStatus.value[0].value) 
        : null;

      return {
        status: statusText,
        isRevoked,
        revokedInfo: isRevoked ? { revocationTime } : null
      };
    } catch (error) {
      console.error('OCSP Decode Error:', {
        message: error.message,
        bufferLength: buffer?.length,
        bufferType: typeof buffer
      });
      return {
        status: 'decodeError',
        isRevoked: false,
        error: error.message
      };
    }
  };
}