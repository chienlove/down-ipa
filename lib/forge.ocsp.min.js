export default function patchOCSP(forge) {
  forge.ocsp = forge.ocsp || {};

  forge.ocsp.getCertID = function(cert, issuer) {
    if (!cert || !issuer) {
      throw new Error('Missing certificate or issuer');
    }

    try {
      const certSerial = new forge.jsbn.BigInteger(cert.serialNumber, 16);
      const issuerNameDer = forge.asn1.toDer(cert.issuer);
      const issuerKey = issuer.publicKey?.subjectPublicKeyInfo?.subjectPublicKey;

      if (!issuerKey) {
        throw new Error('Issuer missing public key');
      }

      return {
        hashAlgorithm: forge.pki.oids['sha1'],
        issuerNameHash: forge.md.sha1.create()
          .update(issuerNameDer.getBytes())
          .digest().getBytes(),
        issuerKeyHash: forge.md.sha1.create()
          .update(issuerKey)
          .digest().getBytes(),
        serialNumber: certSerial.toByteArray()
      };
    } catch (error) {
      console.error('CertID Error:', error);
      throw new Error(`Failed to create CertID: ${error.message}`);
    }
  };

  forge.ocsp.request = function(certID) {
    const oid = forge.pki.oids['sha1'];
    return forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.SEQUENCE, true, [
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OID, false, 
          forge.asn1.oidToDer(oid).getBytes()),
        forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.NULL, false, '')
      ]),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, 
        certID.issuerNameHash),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.OCTETSTRING, false, 
        certID.issuerKeyHash),
      forge.asn1.create(forge.asn1.Class.UNIVERSAL, forge.asn1.Type.INTEGER, false, 
        certID.serialNumber)
    ]);
  };

  forge.ocsp.createRequest = function({ certificate, issuer }) {
    try {
      const certID = forge.ocsp.getCertID(certificate, issuer);
      const request = forge.ocsp.request(certID);

      const tbsRequest = forge.asn1.create(forge.asn1.Class.UNIVERSAL, 
        forge.asn1.Type.SEQUENCE, true, [
          forge.asn1.create(forge.asn1.Class.UNIVERSAL, 
            forge.asn1.Type.SEQUENCE, true, [request])
        ]);

      const ocspRequest = forge.asn1.create(forge.asn1.Class.UNIVERSAL, 
        forge.asn1.Type.SEQUENCE, true, [tbsRequest]);

      const der = forge.asn1.toDer(ocspRequest);
      
      return {
        toDer: () => Buffer.from(der.getBytes(), 'binary'),
        length: der.length()
      };
    } catch (error) {
      console.error('CreateRequest Error:', error);
      throw new Error(`Failed to create OCSP request: ${error.message}`);
    }
  };

  forge.ocsp.decodeResponse = function(buffer) {
    try {
      const bytes = Buffer.isBuffer(buffer) ? buffer.toString('binary') : buffer;
      const obj = forge.asn1.fromDer(bytes);

      if (!obj?.value?.length) {
        return { status: 'malformedResponse', isRevoked: false };
      }

      const responseStatus = obj.value[0]?.value?.[0]?.value?.charCodeAt(0);
      const statusText = [
        'successful', 'malformedRequest', 'internalError', 
        'tryLater', null, 'sigRequired', 'unauthorized'
      ][responseStatus] || 'unknown';

      if (statusText !== 'successful') {
        return { status: statusText, isRevoked: false };
      }

      const singleResp = obj.value[1]?.value?.[0]?.value?.[0]?.value?.[1]?.value?.[0];
      const certStatus = singleResp?.value?.[1];

      if (!certStatus) {
        return { status: statusText, isRevoked: false };
      }

      const isRevoked = certStatus.type === 1;
      const revocationTime = isRevoked 
        ? new Date(certStatus.value[0].value) 
        : null;

      return {
        status: statusText,
        isRevoked,
        revokedInfo: isRevoked ? { revocationTime } : null
      };

    } catch (error) {
      console.error('DecodeResponse Error:', error);
      return {
        status: 'decodeError',
        isRevoked: false,
        error: error.message
      };
    }
  };
}